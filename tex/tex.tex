\documentclass[a4paper,12pt]{ctexrep}

% --- Packages ---
\usepackage{geometry}
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{titlesec} % For custom section formatting
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{caption}

% --- Settings ---
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=black,      
    urlcolor=blue,
}

% Header and Footer
\setlength{\headheight}{15pt}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{疫情模拟系统设计报告}
\fancyhead[R]{\thepage}
% \fancyfoot[C]{C++程序设计}

% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    extendedchars=false,
    escapechar=`,
    texcl=true
}
\lstset{style=mystyle}

% --- Document ---
\begin{document}
\pagenumbering{gobble} % Hide page numbers for front matter

% --- Cover Page ---
\begin{titlepage}
    \centering
    \vspace*{1cm}
    \includegraphics[width=0.8\textwidth]{cover_image.jpg} \\
    \vspace{1.5cm}
    
    {\Huge \bfseries 高级程序设计 \par}
    \vspace{0.5cm}
    {\Huge \bfseries 课程设计 \par}
    \vspace{0.5cm}
    {\Large \bfseries Course Design of Advanced Programming \par}
    
    \vspace{3cm}
    
    {\Large
    \begin{tabular}{lc}
        \textbf{题\quad\quad 目：} & \underline{\makebox[7cm]{传染病疫情模拟与预测系统}} \\ [1em]
        \textbf{学生姓名：} & \underline{\makebox[7cm]{魏中钧}} \\ [1em]
        \textbf{指导教师：} & \underline{\makebox[7cm]{唐朝晖}} \\ [1em]
        \textbf{学\quad\quad 院：} & \underline{\makebox[7cm]{自动化学院}} \\ [1em]
        \textbf{专业班级：} & \underline{\makebox[7cm]{自动化2401班}} \\ [1em]
        \textbf{完成时间：} & \underline{\makebox[7cm]{\today}} \\ [1em]
    \end{tabular}
    }
    
    \vfill
\end{titlepage}

% --- Abstract ---
\begin{center}
    \Large \textbf{摘\quad 要}
\end{center}

传染病的爆发对全球公共卫生安全构成了严峻挑战，利用计算机技术进行疫情数据的管理与趋势预测已成为辅助决策的重要手段。本报告详细阐述了一个基于SIR（Susceptible-Infected-Removed）动力学模型的传染病疫情模拟与预测系统的设计与实现过程。该系统采用C++面向对象编程语言开发，利用STL标准模板库进行高效的数据结构管理，并结合ImGui图形库构建了现代化的用户交互界面，摒弃了传统的控制台操作模式。

系统主要实现了三大核心功能：一是\textbf{分国家、分城市的疫情数据统计与管理}，系统打破了单一地区的限制，支持跨国家、跨区域的多层级数据录入与并行模拟，能够满足从城市级到国家级不同维度的防控需求；二是历史数据的可视化回放，通过图表直观展示疫情发展轨迹；三是基于微分方程的未来趋势预测，系统能够根据输入的历史数据自动估算传染率（$\beta$）和恢复率（$\gamma$），并利用欧拉法（Euler Method）数值求解SIR微分方程组，从而仿真未来的疫情走向。

报告内容涵盖了全生命周期的软件开发过程，包括深度的需求分析、基于MVC模式的概要设计、详细的类与算法设计（如反推参数算法）、程序实现的难点解析（如ImGui的立即模式渲染机制）、以及完善的系统测试。通过本项目的开发，不仅实现了一个具有实用价值的疫情模拟工具，更深入验证了面向对象编程思想在解决复杂数学建模问题中的有效性与灵活性。

\vspace{1em}
\textbf{关键词}：C++；面向对象程序设计；SIR模型；数值模拟；ImGui；数据可视化

\newpage

% --- TOC ---
\tableofcontents
\newpage
\pagenumbering{arabic} % Start counting pages from here
\setcounter{page}{1}

% ----------------------------------------------------------------------
% Chapter 1: Requirement Analysis
% ----------------------------------------------------------------------
\chapter{需求分析}

\section{项目背景与意义}
\subsection{背景}
自2019年底新冠疫情（COVID-19）爆发以来，病毒的高传染性与变异性给全球各国的医疗系统和社会治理带来了巨大压力。在抗击疫情的过程中，数据的产生速度极快且维度众多（如不同地区、不同时间、不同人群分类），单纯依靠人工统计或静态表格（如Excel）难以直观地反映疫情的动态变化规律。

传统的疫情数据分析往往滞后于病毒的传播速度。决策者面临的主要挑战在于如何从海量的碎片化数据中提取出有价值的信息，并据此制定科学的防控策略（如封城、限制出行、疫苗接种等）。这就迫切需要一种能够实时处理多源数据、并具备动态推演能力的计算机辅助系统。通过对历史数据的深度挖掘与可视化展示，结合成熟的传染病动力学模型，我们不仅可以复盘过去的疫情发展脉络，更能对未来的潜在风险进行量化评估，从而实现从“被动应对”到“主动防御”的转变。因此，开发一款能够实时管理疫情数据并具备科学预测功能的计算机系统显得尤为迫切。

\subsection{目的与意义}
本项目旨在综合运用C++高级程序设计课程中所学的知识，开发一个“传染病疫情模拟与预测系统”。
\begin{itemize}
    \item \textbf{理论意义}：
    \begin{enumerate}
        \item \textbf{数学建模的计算机实现}：通过将抽象的数学模型（SIR微分方程组）转化为具体的计算机算法，深入理解计算机仿真技术在公共卫生领域的应用。这一过程不仅验证了数学模型的有效性，也展示了数值计算方法在解决实际问题中的威力。
        \item \textbf{面向对象编程实践}：本项目是面向对象编程（OOP）思想的典型应用场景。通过封装、继承、多态等核心机制，构建出可复用、易维护的代码结构，加深了对软件工程基本原则的理解。
    \end{enumerate}
    \item \textbf{实践意义}：
    \begin{enumerate}
        \item \textbf{辅助决策工具}：系统提供了一个直观、友好的操作界面，帮助用户（如疾控中心工作人员或普通研究者）快速录入数据、观察历史趋势。
        \item \textbf{情景推演能力}：通过动态调整传染率参数（如模拟“封城”导致 $\beta$ 降低），系统能够对不同管控力度下的疫情走向进行仿真推演。这种“如果-那么”（What-If）分析能力，对于制定科学合理的防疫政策具有重要的参考价值。
    \end{enumerate}
\end{itemize}

\section{功能需求分析}
根据用户的使用场景，系统需具备以下核心功能模块：

\subsection{地区数据管理}
系统应具备强大的多维度数据管理能力，支持\textbf{分国家、分城市}的统计输入，允许用户在同一界面下管理跨国界、跨行政区的多组疫情数据。
\begin{itemize}
    \item \textbf{多层级添加}：用户可自由定义地区粒度（如“中国-武汉”、“美国-纽约”），系统应能独立维护每个地理单元的 `Region` 对象及其 SIR 模型参数。
    \item \textbf{跨区域并行}：系统支持同时追踪多个互不干扰的地区数据，方便用户进行横向对比分析（如对比不同国家的抗疫效果）。
    \item \textbf{数据更新}：支持对现有地区的数据进行修改（如每日更新最新的确诊数字）。
    \item \textbf{列表展示}：以表格形式展示所有管理地区的实时概况，并用颜色（红/黄/绿）标识风险等级。
\end{itemize}

\subsection{数据可视化}
为了提供直观的信息展示，系统需集成图表绘制功能。
\begin{itemize}
    \item \textbf{总览柱状图}：在首页展示所有地区的确诊人数对比，方便横向比较。
    \item \textbf{历史趋势图}：针对特定地区，绘制随时间变化的S、I、R三条曲线，清晰展示疫情的爆发、高峰与衰退阶段。
\end{itemize}

\subsection{疫情模拟与预测}
这是本系统的核心的高级功能。
\begin{itemize}
    \item \textbf{参数自动拟合}：系统应能根据用户录入的历史真实数据，自动反推计算出该地区的平均传染率（Beta）和平均恢复率（Gamma），减少人工调参的难度。
    \item \textbf{未来仿真}：基于SIR模型的微分方程，设定预测天数（如未来30天），计算并绘制预测曲线。用户应能动态调整参数（如模拟“封城”导致Beta降低），观察曲线的变化。
\end{itemize}

\section{非功能需求}
\begin{enumerate}
    \item \textbf{易用性}：界面应简洁明了，采用图形化与菜单式交互，降低学习成本。
    \item \textbf{性能}：对于包含数百个数据点的模拟计算，应在毫秒级完成，保证界面流畅不卡顿。
    \item \textbf{健壮性}：对于用户的非法输入（如负数人口、空名称），系统应有校验机制，不会直接崩溃或产生逻辑错误。
    \item \textbf{扩展性}：代码结构应清晰（采用MVC模式），便于未来扩展更复杂的模型（如SEIR）。
\end{enumerate}

% ----------------------------------------------------------------------
% Chapter 2: System Design
% ----------------------------------------------------------------------
\chapter{概要设计}

\section{系统总体架构}
本系统采用分层架构设计，严格遵循“高内聚、低耦合”的软件工程原则。为了应对复杂的业务逻辑和频繁的用户交互，系统并没有采用简单的“一站式”过程化代码，而是被设计为经典的 \textbf{MVC（Model-View-Controller）} 架构。这种架构模式将应用程序分为三个核心组件，各自承担独立的职责，极大地提高了系统的可维护性和扩展性。

MVC 架构的核心优势在于它实现了数据逻辑与界面显示的彻底解耦。这意味着底层的数据处理逻辑（Model）不依赖于特定的界面展示形式（View）；反之，界面的修改或重构也不会影响到核心业务逻辑的稳定性。对于本系统而言，未来如果需要将桌面端界面移植为 Web 端或移动端，只需重写 View 层，而无需修改 Model 层和大部分 Controller 层的代码。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image01.png}
    \caption{系统MVC架构设计图}
    \label{fig:architecture}
\end{figure}

\subsection{模块划分与职责}
\begin{enumerate}
    \item \textbf{Model 层（数据模型）}：
    \begin{itemize}
        \item \textbf{核心职责}：Model 层是系统的“大脑”，负责封装应用程序的所有业务逻辑和数据状态。它不包含任何与界面显示相关的代码，保证了纯粹性。
        \item \textbf{数据管理}：使用 \texttt{EpidemicData} 类作为全局数据仓库，管理所有的地区对象。
        \item \textbf{算法实现}：\texttt{SIRModel} 类封装了传染病动力学方程，负责根据输入的 $\beta, \gamma$ 参数计算下一时刻的疫情状态。
        \item \textbf{状态更新}：提供标准化的接口（如 \texttt{addRegion}, \texttt{update}）供 Controller 调用，确保数据的一致性和完整性。
    \end{itemize}

    \item \textbf{View 层（视图界面）}：
    \begin{itemize}
        \item \textbf{核心职责}：View 层是系统的“脸面”，负责将 Model 层的数据以图形、表格、文本等形式呈现给用户，并提供交互控件（按钮、输入框）。
        \item \textbf{可视化呈现}：利用 ImGui 库的强大绘图能力，将抽象的数值转化为直观的折线图（S-I-R 曲线）和柱状图。
        \item \textbf{用户反馈}：当发生错误或操作成功时，通过弹窗或颜色变化给予用户即时的视觉反馈。
    \end{itemize}

    \item \textbf{Controller 层（逻辑控制）}：
    \begin{itemize}
        \item \textbf{核心职责}：Controller 层是连接 Model 与 View 的“桥梁”。它监听用户的输入事件，并决定如何响应。
        \item \textbf{事件处理}：解析来自鼠标点击、键盘输入的原始信号，将其转化为具体的业务指令（如“开始模拟”、“保存数据”）。
        \item \textbf{流程控制}：位于 \texttt{main.cpp} 的主循环中，维护整个应用程序的状态机（\texttt{AppState}），决定当前应该显示哪个页面，以及何时进行页面跳转。
    \end{itemize}
\end{enumerate}

\section{系统工作流程}
系统采用实时渲染循环（Real-time Rendering Loop）机制，这与普通的游戏引擎机制类似。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image02.png}
    \caption{系统主循环流程示意图}
    \label{fig:main_flow}
\end{figure}

\subsection{主要业务流程}
\begin{enumerate}
    \item \textbf{启动阶段}：程序初始化SDL/OpenGL上下文，加载字体资源（支持中文），并实例化全局 `g\_EpidemicData` 对象。
    \item \textbf{交互阶段}：
    \begin{itemize}
        \item 用户点击“添加城市”，弹出模态对话框。
        \item 用户输入数据并确认，Controller调用 `EpidemicData::addRegion`。
        \item Model更新内存中的 `vector<Region>` 列表。
        \item 下一帧渲染时，View层读取最新的列表并显示在表格中。
    \end{itemize}
    \item \textbf{模拟阶段}：
    \begin{itemize}
        \item 用户在预测页面调整滑动条（Slider）改变Beta值。
        \item View层实时将新参数传递给 `SIRModel`。
        \item `SIRModel` 重新计算未来30天的轨迹，View层实时刷新曲线图。
    \end{itemize}
\end{enumerate}

% ----------------------------------------------------------------------
% Chapter 3: Program Design
% ----------------------------------------------------------------------
\chapter{程序设计}

本章将详细介绍核心类的设计与实现，以及传染病动力学模型的数学推导与数值解算法。

\section{核心类结构设计}

系统采用面向对象的方法对现实世界进行建模。主要的类及其关系如下：

\subsection{全局数据管理器}
这是一个管理类，在整个应用程序生命周期中通常只存在一个实例（类似于单例模式的使用）。
\begin{itemize}
    \item \textbf{成员变量}：\texttt{std::vector\textless Region\textgreater regions}。使用STL向量容器动态存储所有地区对象，支持运行时的动态扩容。
    \item \textbf{核心方法}：
    \begin{itemize}
        \item \texttt{addRegion(...)}: 负责对象的创建与初始化，并将其推入向量末尾。
        \item \texttt{calculateRiskLevel(...)}: 一个静态工具函数，根据活跃病例数占总人口的比例，返回 \texttt{RiskLevel} 枚举值（High/Medium/Low），实现了业务逻辑的封装。
    \end{itemize}
\end{itemize}

\subsection{地区实体类}
\texttt{Region} 结构体代表了一个独立的地理单元。
\begin{itemize}
    \item \textbf{数据成员}：包含基础信息（名称、人口）和当前疫情状态（确诊、治愈、死亡）。
    \item \textbf{组合关系}：每个 \texttt{Region} 对象内部包含一个 \texttt{SIRModel} 对象（\texttt{simulation}）。体现了“组合优于继承”的设计原则，使得地区数据与模拟逻辑绑定。
    \item \textbf{历史数据}：\texttt{std::vector\textless HistoricalRecord\textgreater history} 存储了该地区过去多天的真实数据，用于后续的参数拟合。
\end{itemize}

\subsection{传染病模型类}
这是系统的数学核心。
\begin{itemize}
    \item \textbf{封装性}：将 $S, I, R$ 的状态值以及 $\beta, \gamma$ 参数私有化，仅通过Getter/Setter暴露接口，保证了数据的安全性。
    \item \textbf{模拟能力}：提供了 \texttt{run(int days)} 接口，能够基于当前状态向后推演任意天数。
\end{itemize}

\section{SIR 模型数学原理与实现}

系统基于经典的SIR（Susceptible-Infected-Removed）隔室模型。该模型由Kermack和McKendrick于1927年提出，是传染病动力学中最基础且应用最广泛的模型之一。模型建立在以下基本假设之上：
\begin{enumerate}
    \item \textbf{人口恒定}：假设在研究期间，总人口 $N$ 保持不变，不考虑出生率和自然死亡率。即 $N = S(t) + I(t) + R(t)$ 对任意时间 $t$ 恒成立。
    \item \textbf{均匀混合}：假设人群是均匀混合的（Homogeneous Mixing），即任何一个个体与群体中其他个体的接触概率是相等的。
    \item \textbf{终身免疫}：假设康复者（Removed）获得终身免疫力，不会再次变为易感者。
\end{enumerate}

人群被划分为三个互斥的仓室（Compartment）：
\begin{itemize}
    \item \textbf{S (Susceptible, 易感者)}：指未被感染但缺乏免疫力的人群。在疾病传播初期，绝大多数人口属于此类。
    \item \textbf{I (Infected, 感染者)}：指已被感染并具有传染能力的人群。这部分人群是病毒传播的源头。
    \item \textbf{R (Removed, 移出者)}：指退出传染过程的人群，包括因病治愈获得免疫力的人，或因病死亡的人。
\end{itemize}

\subsection{微分方程模型}
系统的核心动力学由以下一组非线性常微分方程（Ordinary Differential Equations, ODEs）描述。这些方程描述了三个仓室之间人数随时间的变化率：

\begin{equation}
\frac{dS}{dt} = - \frac{\beta S I}{N}
\end{equation}
\begin{equation}
\frac{dI}{dt} = \frac{\beta S I}{N} - \gamma I
\end{equation}
\begin{equation}
\frac{dR}{dt} = \gamma I
\end{equation}

\textbf{方程物理意义解析}：
\begin{itemize}
    \item \textbf{方程 (4.1)}：表示易感者数量的变化率。$\frac{S}{N}$ 是易感者在总人口中的比例，$\beta I$ 是一个感染者单位时间内有效接触的人数。因此，$\frac{\beta S I}{N}$ 代表单位时间内新被感染的人数。由于易感者不仅减少，所以符号为负。
    \item \textbf{方程 (4.2)}：表示感染者数量的变化率。它由两部分组成：第一项 $\frac{\beta S I}{N}$ 是从易感者转化的新增感染者；第二项 $- \gamma I$ 是因治愈或死亡而离开感染状态的人数。
    \item \textbf{方程 (4.3)}：表示移出者数量的变化率。即单位时间内有 $\gamma I$ 的人从感染者转变为移出者。
\end{itemize}

其中模型参数定义如下：
\begin{itemize}
    \item $\beta$ (Beta)：\textbf{有效接触率}，代表病毒的传染能力。它反映了社会互动的频率和病毒本身的传播性。
    \item $\gamma$ (Gamma)：\textbf{恢复率}，代表医疗治愈能力。它是平均感染周期 $D$ 的倒数，即 $\gamma \approx 1/D$。例如，如果平均病程为10天，则 $\gamma = 0.1$。
\end{itemize}

\subsection{数值解算法 (欧拉法)}
由于 SIR 模型是非线性微分方程组，除了极少数特殊情况外，很难求得其解析解（Analytical Solution）。因此，在计算机仿真中，我们通常采用数值方法求取其近似解。本项目出于计算效率和实现复杂度的平衡，采用了\textbf{显式欧拉法（Forward Euler Method）}。

欧拉法的基本思想是将连续的时间 $t$ 离散化为一系列时间点 $t_0, t_1, ..., t_n$，其中 $t_{n+1} = t_n + \Delta t$。在足够小的时间步长 $\Delta t$ 内，假设函数的变化率是恒定的，从而用差分代替微分。

设定时间步长 $\Delta t = 1$（单位：天），则导数 $\frac{dX}{dt}$ 近似为 $\frac{X_{t+1} - X_t}{\Delta t}$。代入原方程组，可得如下递推公式，这正是代码中 \texttt{run\_single\_step} 函数的核心逻辑：

\begin{align}
S_{t+1} &= S_t - (\frac{\beta S_t I_t}{N}) \\
I_{t+1} &= I_t + (\frac{\beta S_t I_t}{N}) - (\gamma I_t) \\
R_{t+1} &= R_t + (\gamma I_t)
\end{align}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image03.png}
    \caption{SIR模拟算法核心流程 (NS图)}
    \label{fig:ns_chart}
\end{figure}

\section{参数自适应拟合算法}
为了让模型更贴近现实，系统实现了 \texttt{calculateAverageBeta} 函数。该函数不依赖用户猜测，而是根据真实历史数据自动反算 $\beta$ 值。

\textbf{算法逻辑：}
\begin{enumerate}
    \item 遍历历史记录 \texttt{history} 中的每一天 $t$。
    \item 计算当天的新增感染数：$\Delta I_{new} \approx Confirmed_{t+1} - Confirmed_{t}$。
    \item 根据 $dI/dt$ 的生成项 $\frac{\beta S I}{N} \approx \Delta I_{new}$，反解出当天的瞬时 $\beta$：
    \[
    \beta_t = \frac{N \cdot \Delta I_{new}}{S_t \cdot I_t}
    \]
    \item 剔除异常值（如数据录入错误导致的负数或极大值）后，计算所有 $\beta_t$ 的算术平均值，作为最终模型的输入参数。
\end{enumerate}

\begin{lstlisting}[language=C++, caption={核心拟合算法片段}]
double Region::calculateAverageBeta() const {
    double sumBeta = 0.0;
    int count = 0;
    for (size_t t = 0; t < history.size() - 1; ++t) {
        // 利用反推公式计算 Beta\_t
        double newInfections = nextDay.confirmed - today.confirmed;
        // 防止分母为0和数值溢出的保护逻辑
        if (S_today > 0 && activeToday > 0) {
            double dailyBeta = (population * newInfections) / (S_today * activeToday);
            if (dailyBeta > 0 && dailyBeta < 5.0) { // 过滤噪点
                sumBeta += dailyBeta;
                count++;
            }
        }
    }
    return (count > 0) ? (sumBeta / count) : 0.2; // 默认值回退
}
\end{lstlisting}

% ----------------------------------------------------------------------
% Chapter 4: Debugging & Analysis
% ----------------------------------------------------------------------
\chapter{调试分析}

在软件开发过程中，调试是确保代码质量的关键环节。本章记录了开发过程中遇到的典型问题、原因分析以及最终的解决方案。

\section{常见问题与解决}

\subsection{问题一：ImGui 控件交互冲突}
\textbf{故障现象}：在“地区列表”页面中，每一行都有一个“删除”按钮。但在点击第3行的删除按钮时，往往没有反应，或者错误地删除了第1行的数据。
\textbf{原因分析}：ImGui 采用立即模式渲染（Immediate Mode GUI）。如果在循环中生成多个相同标签（Label）的按钮（例如都叫 "Delete"），ImGui 无法区分它们的ID哈希值，导致事件处理混乱。
\textbf{解决方案}：利用 \texttt{ImGui::PushID(index)} 和 \texttt{ImGui::PopID()} 机制。在循环体的开始处压入当前的循环索引 \texttt{i} 作为ID标识，确保每个按钮拥有唯一的哈希上下文。

\subsection{问题二：SIR模型数值震荡与溢出}
\textbf{故障现象}：在模拟高传染率（Beta > 1.0）场景时，易感人数 $S$ 突然变成负数，或者总人口数 $S+I+R$ 不守恒。
\textbf{原因分析}：
\begin{itemize}
    \item \textbf{原因1}：欧拉法的时间步长 $\Delta t=1$ 对于变化剧烈的非线性方程来说可能过大，导致截断误差累积。
    \item \textbf{原因2}：计算过程中未做边界检查，\texttt{newInfections} 可能大于当前的 \texttt{S}。
\end{itemize}
\textbf{解决方案}：
1. 引入边界钳制（Clamping）：\texttt{S = std::max(0.0, S - newInfections)}。
2. 增加输入校验：确保拟合出的 \texttt{beta} 和 \texttt{gamma} 不会超过合理范围（如 $\beta < 5.0$）。

\subsection{问题三：中文字符显示乱码}
\textbf{故障现象}：界面上的所有中文（如“武汉”、“确诊”）都显示为 `?` 或方框。
\textbf{解决方案}：ImGui 默认只加载 ASCII 字符集。需要在初始化阶段加载包含中文字形的字体文件（如 \texttt{SimHei.ttf} 或 \texttt{DroidSansFallback.ttf}），并设置 \texttt{ImGuiIO} 的 \texttt{GetGlyphRangesChineseFull}。

\subsection{问题四：内存泄漏与资源管理}
\textbf{故障现象}：程序运行一段时间后，任务管理器显示内存占用持续飙升，最终导致程序崩溃（Crash）。
\textbf{原因分析}：
\begin{enumerate}
    \item 在 C++ 中手动使用 \texttt{new} 分配了 `Region` 对象，但在删除地区时忘记调用 \texttt{delete}。
    \item ImGui 的纹理资源在每一帧被重复加载，但没有释放。
\end{enumerate}
\textbf{解决方案}：
\begin{enumerate}
    \item 全面采用现代 C++ 的智能指针（Smart Pointers）。将 `std::vector<Region*>` 改为 `std::vector<std::unique\_ptr<Region>>`，利用 RAII（资源获取即初始化）机制，确保对象在离开作用域时自动释放内存。
    \item 将纹理加载逻辑移至 \texttt{OnStart} 初始化阶段，仅加载一次，避免在 \texttt{OnRender} 循环中进行 IO 操作。
\end{enumerate}

% ----------------------------------------------------------------------
% Chapter 5: Test Results
% ----------------------------------------------------------------------
\chapter{测试结果}

为了验证系统的正确性与健壮性，我们设计了多组功能测试用例。

\section{功能测试用例}

\begin{table}[H]
\centering
\caption{系统功能测试用例表}
\begin{tabular}{|c|l|l|l|c|}
\hline
\textbf{ID} & \textbf{测试项目} & \textbf{输入数据/操作} & \textbf{预期结果} & \textbf{结果} \\ \hline
TC01 & 添加新地区 & \begin{tabular}[c]{@{}l@{}}名称: 测试市\\ 人口: 10000\\ 初始确诊: 50\end{tabular} & 列表显示该城市，风险等级为"高" & 通过 \\ \hline
TC02 & 非法数据录入 & \begin{tabular}[c]{@{}l@{}}确诊数: -100\\ 人口: 0\end{tabular} & 系统弹窗警告，不允许保存 & 通过 \\ \hline
TC03 & 删除操作 & 点击第2行的"删除" & 第2行消失，总行数减1 & 通过 \\ \hline
TC04 & 模拟预测 & 设定 Beta=0.5, 天数=30 & 绘制S/I/R曲线，峰值在第15天左右 & 通过 \\ \hline
TC05 & 历史回放 & 拖动历史进度条 & 数据表格实时更新为当天的数据 & 通过 \\ \hline
\end{tabular}
\end{table}

\section{界面展示}
系统的最终运行效果如下所示：

\subsection{系统首页 (仪表盘)}
首页展示了全国视角的宏观数据，通过颜色编码（红/绿/灰）直观反映各地区的疫情严重程度。
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image04.png}
    \caption{系统首页 - 全国疫情总览与风险评估}
    \label{fig:dashboard}
\end{figure}

\subsection{数据管理与录入}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image05.png}
    \caption{数据录入界面 - 支持错误提示与校验}
    \label{fig:data_entry}
\end{figure}

\subsection{预测结果展示}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image06.png}
    \caption{SIR模型预测结果 - 感染曲线的峰值预测}
    \label{fig:prediction}
\end{figure}

\subsection{历史数据修正}
为了应对真实世界中数据可能出现的录入错误或滞后修正，系统提供了历史数据编辑功能。
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image07.png}
    \caption{历史数据修正界面 - 表格化编辑与实时验证}
    \label{fig:history_edit}
\end{figure}

\section{测试总结}
经系统测试，本软件在 Windows 10/11 环境下运行稳定，内存占用保持在 50MB 以内。所有的核心功能（CRUD、模拟、绘图）均符合设计预期，能够正确处理各类边界情况（如0人口、极大数值），具备了作为课程设计作品的交付质量。

% ----------------------------------------------------------------------
% Chapter 6: Summary
% ----------------------------------------------------------------------
\chapter{总结与分析}

\section{项目总结}
本项目历时数周，成功设计并实现了一个基于 C++ 和 ImGui 的传染病疫情模拟与预测系统。通过该项目，我在以下几个方面获得了显著的提升：
\begin{itemize}
    \item \textbf{工程化思维}：从最初的需求模糊到最终的代码交付，经历了一套完整的软件工程流程。学会了如何将复杂的现实问题（疫情传播）抽象为数学模型，再转化为计算机对象（Classes）。
    \item \textbf{图形界面开发}：深入掌握了 ImGui 这种立即模式 GUI 库的使用。相比于传统的 Qt/MFC，ImGui 将渲染逻辑与业务逻辑高度紧凑地结合，非常适合用于实时仿真和工具开发。
    \item \textbf{算法能力}：通过实现 SIR 微分方程的数值解，复习了高等数学知识，并学会了如何处理浮点数精度、边界条件（如人口非负）和数据拟合问题。
\end{itemize}

\section{不足与改进}
虽然系统已具备基本功能，但受限于时间和开发经验，仍存在以下局限性，这也是未来的主要改进方向：

\subsection{1. 模型精度的提升 (SEIR 模型)}
当前使用的 SIR 模型较为理想化。对于新冠（COVID-19）这样具有显著潜伏期的病毒，SIR 模型无法准确反映"已感染但未发病"（Exposed）人群的传播风险。
\textbf{改进方案}：引入 \textbf{SEIR} 模型，增加一个 \textbf{E (Exposed)} 仓室。
\begin{equation}
\frac{dE}{dt} = \frac{\beta S I}{N} - \sigma E
\end{equation}
其中 $\sigma$ 是潜伏期倒数。这将使预测曲线的峰值出现得比 SIR 模型更晚，但更符合流行病学规律。

\subsection{2. 数据持久化 (Database Integration)}
目前系统采用内存数据库（In-Memory），通过 CSV 文件进行冷备份。但在高并发或大数据量下，这种方式效率低下且不安全。
\textbf{改进方案}：引入轻量级嵌入式数据库 \textbf{SQLite}。
\begin{itemize}
    \item 设计关系型数据表：\texttt{Table\_Regions}, \texttt{Table\_DailyData}。
    \item 利用 SQL 语句实现复杂的查询分析（如“查询确诊增长最快的前5个城市”）。
\end{itemize}

\subsection{3. 复杂网络传播模型 (Network Model)}
目前的模拟是将每个地区视为孤岛。然而现实世界中，城市之间存在复杂的人员流动网络。
\textbf{改进方案}：构建 \textbf{元胞自动机 (Cellular Automata)} 或 \textbf{小世界网络 (Small-world Network)} 模型。
\begin{itemize}
    \item 定义地区间的邻接矩阵 $A_{ij}$，表示城市 $i$ 到城市 $j$ 的交通流量。
    \item 修改微分方程，增加输入项 $\sum A_{ji} \frac{I_j}{N_j} $，模拟输入性病例对本地疫情的影响。
\end{itemize}

% ----------------------------------------------------------------------
% Appendix
% ----------------------------------------------------------------------
\chapter*{附录：主要源程序清单}
\addcontentsline{toc}{chapter}{附录：源程序}

\section*{File: src/DataModel.h}
\lstinputlisting[language=C++]{../src/DataModel.h}

\section*{File: src/DataModel.cpp}
\lstinputlisting[language=C++]{../src/DataModel.cpp}

\section*{File: src/main.cpp (Core Parts)}
\begin{lstlisting}[language=C++]
// 节选 main.cpp 核心逻辑
// ...
void OnRender() {
    // Main Loop
}
// ...
\end{lstlisting}

\end{document}
